1.跨域问题需要同时满足三个条件：浏览器限制/跨域/xhr请求

2.冲破浏览器限制的方式：
	1.在启动浏览器的时候使用cmd添加一个命令：chrome --disable-web-security --user-data-dir=g:\temp3  该命令用于禁止浏览器做跨域检查
	这一个方式可以不用理会了，因为基本上没有什么作用
	
	2.添加响应头
	

3.使用jsonp来解决跨域的原理：jsonp其实质就是将xhr请求改成一个script请求，将返回的数据封装成一个js函数然后动态创建js来获取数据
	$.ajax.dataType: "jsonp" 来指定发送jsonp格式数据
	$.ajax.jsonp: funName 来指定双方约定的回调函数名
  默认情况下，jsonp请求会发送两个参数，第一个参数就是回调函数的随机名称，第二个参数就是禁止缓存该请求数据的随机参数，想要启动缓存则添加一个请求参数
	$.ajax.cache: true  该值默认为false
  在后台需要使用切面来添加一个回调函数名，具体还需要再看下课程怎么写的，是一个特定的注解

4.jsonp的弊端：
	1.服务器需要改动代码来进行相应的支持
	2.jsonp请求只支持get请求，其他的请求都会被转换成get请求，所以受到了很大的限制
	3.发送的不是xhr请求  这个不了解是啥弊端
	
5.浏览器限制跨域的原理：
	浏览器会为每一个请求都先判断是否与调用方异域，如果异域就会在该请求中添加一个origin请求头，用于标识调用方的域，然后对于简单的请求会先执行该请求，然后在
	返回的响应头中查找是否有允许该域访问数据的标识，如果没有，就会报跨域错误，虽然请求完成，但是还是会报跨域的错误

6.解决方案：
	对于直接在服务端解决的方式来说，可以在请求中的响应头中添加对应的响应头数据，比如允许指定的域访问就添加该响应头数据：Aceess-Control-Allow-Origin
	  指定允许跨域的方法：Access-Control-Allow-Method  其余的去网上百度吧
	  在后端添加响应头数据的方式：response.addHeader(key, val);
	  
7.在发送ajax请求的时候来添加请求头的两种参数方式：
	$.ajax.headers: {key: val}
	$.ajax.beforeSend: function(xhr){ xhr.setRequestHeader(key, val);}
	
8.简单请求和非简单请求的定义：
	简单请求需要满足三个条件：
		1.请求方法为：get/head/post
		2.请求header里面无自定义请求头数据
		3.Content-Type为以下几种：text/plain  multipart/form-data  application/x-www-form-urlencoded
		
	常见的非请求头有：
		1.put/delete方法的ajax请求
		2.发送json格式的ajax请求
		3.带自定义头的ajax请求
		
	对于简单请求，浏览器一般都是先执行请求，然后判断跨域是否允许
	对于非简单请求，浏览器会先发送options预检命令，用于先判断该请求是否允许跨域，然后在执行请求，也就是会发送两个请求，对于成功的预检命令，默认情况下
	是每次都会发送预检命令的，想要缓存预检命令可以添加响应头: 这个没找到了，可以去网上百度一下看看了
	
9.另外，对于跨域的问题还有一个问题，就是在发送带有cookie参数的ajax请求的时候，就算是Access-Control-Allow-Origin 设置为*也是会报错的，因为这种类型的请求
  只能是指定url，也就是不能使用通配符，所以可以先通过request来获取该请求头的值，然后在传给响应头
  
10.通过反向代理的方式也可以解决跨域的请求，就是将localhost:8081/的请求使用当前域下面的/test请求来代理，这样的话，在浏览器看来就是一个同域的请求，而实际上
   它是一个跨域的请求
   
11.Spring解决跨域问题的方式很简单，直接使用一个注解就可以了，@CrossOrigin 不知道是SpringBoot的特性还是Spring的，还没试过
   已经试过了，是SpringMVC4.2版本之后新增的一个支持跨域的注解